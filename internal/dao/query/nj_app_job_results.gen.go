// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"
	"natsjob/internal/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newNjAppJobResult(db *gorm.DB, opts ...gen.DOOption) njAppJobResult {
	_njAppJobResult := njAppJobResult{}

	_njAppJobResult.njAppJobResultDo.UseDB(db, opts...)
	_njAppJobResult.njAppJobResultDo.UseModel(&model.NjAppJobResult{})

	tableName := _njAppJobResult.njAppJobResultDo.TableName()
	_njAppJobResult.ALL = field.NewAsterisk(tableName)
	_njAppJobResult.ID = field.NewInt64(tableName, "id")
	_njAppJobResult.NamespaceId = field.NewInt64(tableName, "namespace_id")
	_njAppJobResult.Namespace = field.NewString(tableName, "namespace")
	_njAppJobResult.AppID = field.NewInt64(tableName, "app_id")
	_njAppJobResult.AppName = field.NewString(tableName, "app_name")
	_njAppJobResult.JobId = field.NewInt64(tableName, "job_id")
	_njAppJobResult.JobName = field.NewString(tableName, "job_name")
	_njAppJobResult.Category = field.NewString(tableName, "category")
	_njAppJobResult.Model = field.NewString(tableName, "model")
	_njAppJobResult.Status = field.NewString(tableName, "status")
	_njAppJobResult.Reason = field.NewString(tableName, "reason")
	_njAppJobResult.MonitorStatus = field.NewString(tableName, "monitor_status")
	_njAppJobResult.MonitorPayload = field.NewString(tableName, "monitor_payload")
	_njAppJobResult.TimeSpan = field.NewInt64(tableName, "time_span")
	_njAppJobResult.StartAt = field.NewTime(tableName, "start_at")
	_njAppJobResult.EndAt = field.NewTime(tableName, "end_at")
	_njAppJobResult.ExpiredAt = field.NewTime(tableName, "expired_at")
	_njAppJobResult.CreatedAt = field.NewTime(tableName, "created_at")
	_njAppJobResult.UpdatedAt = field.NewTime(tableName, "updated_at")

	_njAppJobResult.fillFieldMap()

	return _njAppJobResult
}

type njAppJobResult struct {
	njAppJobResultDo njAppJobResultDo

	ALL            field.Asterisk
	ID             field.Int64  // '任务id'
	NamespaceId    field.Int64  // '命名空间ID'
	Namespace      field.String // '命名空间'
	AppID          field.Int64  // '应用ID'
	AppName        field.String // '应用名称'
	JobId          field.Int64  // '应用作业id'
	JobName        field.String // '作业名称'
	Category       field.String // '策略'
	Model          field.String // '模式'
	Status         field.String // 状态
	Reason         field.String // '结果说明'
	MonitorStatus  field.String // '监控状态'
	MonitorPayload field.String // '监控随路数据'
	TimeSpan       field.Int64  // '耗时'
	StartAt        field.Time   // '开始时间'
	EndAt          field.Time   // '结束时间'
	ExpiredAt      field.Time   // '过期时间'
	CreatedAt      field.Time   // '创建时间'
	UpdatedAt      field.Time   // '更新时间'

	fieldMap map[string]field.Expr
}

func (n njAppJobResult) Table(newTableName string) *njAppJobResult {
	n.njAppJobResultDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n njAppJobResult) As(alias string) *njAppJobResult {
	n.njAppJobResultDo.DO = *(n.njAppJobResultDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *njAppJobResult) updateTableName(table string) *njAppJobResult {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewInt64(table, "id")
	n.NamespaceId = field.NewInt64(table, "namespace_id")
	n.Namespace = field.NewString(table, "namespace")
	n.AppID = field.NewInt64(table, "app_id")
	n.AppName = field.NewString(table, "app_name")
	n.JobId = field.NewInt64(table, "job_id")
	n.JobName = field.NewString(table, "job_name")
	n.Category = field.NewString(table, "category")
	n.Model = field.NewString(table, "model")
	n.Status = field.NewString(table, "status")
	n.Reason = field.NewString(table, "reason")
	n.MonitorStatus = field.NewString(table, "monitor_status")
	n.MonitorPayload = field.NewString(table, "monitor_payload")
	n.TimeSpan = field.NewInt64(table, "time_span")
	n.StartAt = field.NewTime(table, "start_at")
	n.EndAt = field.NewTime(table, "end_at")
	n.ExpiredAt = field.NewTime(table, "expired_at")
	n.CreatedAt = field.NewTime(table, "created_at")
	n.UpdatedAt = field.NewTime(table, "updated_at")

	n.fillFieldMap()

	return n
}

func (n *njAppJobResult) WithContext(ctx context.Context) INjAppJobResultDo {
	return n.njAppJobResultDo.WithContext(ctx)
}

func (n njAppJobResult) TableName() string { return n.njAppJobResultDo.TableName() }

func (n njAppJobResult) Alias() string { return n.njAppJobResultDo.Alias() }

func (n njAppJobResult) Columns(cols ...field.Expr) gen.Columns {
	return n.njAppJobResultDo.Columns(cols...)
}

func (n *njAppJobResult) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *njAppJobResult) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 19)
	n.fieldMap["id"] = n.ID
	n.fieldMap["namespace_id"] = n.NamespaceId
	n.fieldMap["namespace"] = n.Namespace
	n.fieldMap["app_id"] = n.AppID
	n.fieldMap["app_name"] = n.AppName
	n.fieldMap["job_id"] = n.JobId
	n.fieldMap["job_name"] = n.JobName
	n.fieldMap["category"] = n.Category
	n.fieldMap["model"] = n.Model
	n.fieldMap["status"] = n.Status
	n.fieldMap["reason"] = n.Reason
	n.fieldMap["monitor_status"] = n.MonitorStatus
	n.fieldMap["monitor_payload"] = n.MonitorPayload
	n.fieldMap["time_span"] = n.TimeSpan
	n.fieldMap["start_at"] = n.StartAt
	n.fieldMap["end_at"] = n.EndAt
	n.fieldMap["expired_at"] = n.ExpiredAt
	n.fieldMap["created_at"] = n.CreatedAt
	n.fieldMap["updated_at"] = n.UpdatedAt
}

func (n njAppJobResult) clone(db *gorm.DB) njAppJobResult {
	n.njAppJobResultDo.ReplaceConnPool(db.Statement.ConnPool)
	return n
}

func (n njAppJobResult) replaceDB(db *gorm.DB) njAppJobResult {
	n.njAppJobResultDo.ReplaceDB(db)
	return n
}

type njAppJobResultDo struct{ gen.DO }

type INjAppJobResultDo interface {
	gen.SubQuery
	Debug() INjAppJobResultDo
	WithContext(ctx context.Context) INjAppJobResultDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() INjAppJobResultDo
	WriteDB() INjAppJobResultDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) INjAppJobResultDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INjAppJobResultDo
	Not(conds ...gen.Condition) INjAppJobResultDo
	Or(conds ...gen.Condition) INjAppJobResultDo
	Select(conds ...field.Expr) INjAppJobResultDo
	Where(conds ...gen.Condition) INjAppJobResultDo
	Order(conds ...field.Expr) INjAppJobResultDo
	Distinct(cols ...field.Expr) INjAppJobResultDo
	Omit(cols ...field.Expr) INjAppJobResultDo
	Join(table schema.Tabler, on ...field.Expr) INjAppJobResultDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INjAppJobResultDo
	RightJoin(table schema.Tabler, on ...field.Expr) INjAppJobResultDo
	Group(cols ...field.Expr) INjAppJobResultDo
	Having(conds ...gen.Condition) INjAppJobResultDo
	Limit(limit int) INjAppJobResultDo
	Offset(offset int) INjAppJobResultDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INjAppJobResultDo
	Unscoped() INjAppJobResultDo
	Create(values ...*model.NjAppJobResult) error
	CreateInBatches(values []*model.NjAppJobResult, batchSize int) error
	Save(values ...*model.NjAppJobResult) error
	First() (*model.NjAppJobResult, error)
	Take() (*model.NjAppJobResult, error)
	Last() (*model.NjAppJobResult, error)
	Find() ([]*model.NjAppJobResult, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NjAppJobResult, err error)
	FindInBatches(result *[]*model.NjAppJobResult, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.NjAppJobResult) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INjAppJobResultDo
	Assign(attrs ...field.AssignExpr) INjAppJobResultDo
	Joins(fields ...field.RelationField) INjAppJobResultDo
	Preload(fields ...field.RelationField) INjAppJobResultDo
	FirstOrInit() (*model.NjAppJobResult, error)
	FirstOrCreate() (*model.NjAppJobResult, error)
	FindByPage(offset int, limit int) (result []*model.NjAppJobResult, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INjAppJobResultDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n njAppJobResultDo) Debug() INjAppJobResultDo {
	return n.withDO(n.DO.Debug())
}

func (n njAppJobResultDo) WithContext(ctx context.Context) INjAppJobResultDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n njAppJobResultDo) ReadDB() INjAppJobResultDo {
	return n.Clauses(dbresolver.Read)
}

func (n njAppJobResultDo) WriteDB() INjAppJobResultDo {
	return n.Clauses(dbresolver.Write)
}

func (n njAppJobResultDo) Session(config *gorm.Session) INjAppJobResultDo {
	return n.withDO(n.DO.Session(config))
}

func (n njAppJobResultDo) Clauses(conds ...clause.Expression) INjAppJobResultDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n njAppJobResultDo) Returning(value interface{}, columns ...string) INjAppJobResultDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n njAppJobResultDo) Not(conds ...gen.Condition) INjAppJobResultDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n njAppJobResultDo) Or(conds ...gen.Condition) INjAppJobResultDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n njAppJobResultDo) Select(conds ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n njAppJobResultDo) Where(conds ...gen.Condition) INjAppJobResultDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n njAppJobResultDo) Order(conds ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n njAppJobResultDo) Distinct(cols ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n njAppJobResultDo) Omit(cols ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n njAppJobResultDo) Join(table schema.Tabler, on ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n njAppJobResultDo) LeftJoin(table schema.Tabler, on ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n njAppJobResultDo) RightJoin(table schema.Tabler, on ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n njAppJobResultDo) Group(cols ...field.Expr) INjAppJobResultDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n njAppJobResultDo) Having(conds ...gen.Condition) INjAppJobResultDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n njAppJobResultDo) Limit(limit int) INjAppJobResultDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n njAppJobResultDo) Offset(offset int) INjAppJobResultDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n njAppJobResultDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INjAppJobResultDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n njAppJobResultDo) Unscoped() INjAppJobResultDo {
	return n.withDO(n.DO.Unscoped())
}

func (n njAppJobResultDo) Create(values ...*model.NjAppJobResult) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n njAppJobResultDo) CreateInBatches(values []*model.NjAppJobResult, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n njAppJobResultDo) Save(values ...*model.NjAppJobResult) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n njAppJobResultDo) First() (*model.NjAppJobResult, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.NjAppJobResult), nil
	}
}

func (n njAppJobResultDo) Take() (*model.NjAppJobResult, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.NjAppJobResult), nil
	}
}

func (n njAppJobResultDo) Last() (*model.NjAppJobResult, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.NjAppJobResult), nil
	}
}

func (n njAppJobResultDo) Find() ([]*model.NjAppJobResult, error) {
	result, err := n.DO.Find()
	return result.([]*model.NjAppJobResult), err
}

func (n njAppJobResultDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NjAppJobResult, err error) {
	buf := make([]*model.NjAppJobResult, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n njAppJobResultDo) FindInBatches(result *[]*model.NjAppJobResult, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n njAppJobResultDo) Attrs(attrs ...field.AssignExpr) INjAppJobResultDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n njAppJobResultDo) Assign(attrs ...field.AssignExpr) INjAppJobResultDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n njAppJobResultDo) Joins(fields ...field.RelationField) INjAppJobResultDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n njAppJobResultDo) Preload(fields ...field.RelationField) INjAppJobResultDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n njAppJobResultDo) FirstOrInit() (*model.NjAppJobResult, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.NjAppJobResult), nil
	}
}

func (n njAppJobResultDo) FirstOrCreate() (*model.NjAppJobResult, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.NjAppJobResult), nil
	}
}

func (n njAppJobResultDo) FindByPage(offset int, limit int) (result []*model.NjAppJobResult, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n njAppJobResultDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n njAppJobResultDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n njAppJobResultDo) Delete(models ...*model.NjAppJobResult) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *njAppJobResultDo) withDO(do gen.Dao) *njAppJobResultDo {
	n.DO = *do.(*gen.DO)
	return n
}
